# 正则表达式
"""
记录文本规则的代码
匹配或者查找符合规则的字符串
"""
import re

"""
匹配返回结果对象
result = re.match(正则表达式，要匹配的字符串)

提取数据
result.group()
"""
# 匹配表达式
# 单个字符匹配
r"""
符号                功能
 .           匹配任意一个字符，除了\n
[]           匹配[]中列举的字符
\d           匹配数字，即0-9
\D           匹配非数子
\s           匹配空白，即空格，tab键\t，空行\n
\S           匹配非空白
\w           匹配非特殊字符，即0-9，a-z，A-Z
\W           匹配特殊字符，即非字母，非数字，非汉字
"""
# 多个字符匹配
# 必须与前面单个字符匹配一起用
r"""
符号                功能
*            匹配前一个字符出现0次或者无限次，即可有可无(任意次)
+            匹配前一个字符出现1次或者无限次，即至少有一次
?            匹配前一个字符出现1次或者0次，即要么有1次，要么没有
{m}          匹配前一个字符出现m次
{m,n}        匹配前一个字符出现m-n次
"""
# 匹配开头和结尾
r"""
符号                功能
^               匹配字符串开头
$               匹配字符串结尾       
[^指定字符]      匹配除了指定字符以外的所有字符
"""
# 分组匹配
r"""
符号                功能
|               匹配左右任意一个表达式（或）
()              把括号的表达式作为一个分组
\num            引用分组num匹配到的字符串
(?P<name>)      分组起别名
(?P=name)       引用分组别名
\\1             引用第一分组的内容，第一个\只是表示转义
\\n             引用第n分组的内容，n分组存在       
"""


def test01():
    res = re.match('0\d{2}-\d{8}', '010-34319086')
    print(res)
    print(res.group())


def test02():
    # 需求1：https中s可能有，可能没有
    re.match('https?', 'https')  # 此处不能用*

    # 需求2：匹配8位密码，可以是大小写、数字、下划线
    re.match('[a-zA-Z0-9_]{8}', 'sadsdfadsda')  # 前八位，可多可少
    # 完全匹配，一位不能多，一位不能少
    re.fullmatch('[a-zA-Z0-9_]{8}', '')

    # 需求3：匹配出8到20位的密码，可以是大小写，数字，下划线
    re.match('[a-zA-Z0-9_]{8,20}', 'asdfswdasda')

    # 需求4：匹配大小写字母最少出现8次
    re.match('[a-zA-Z]{8,}')

    # 需求5：匹配大小写字母最多出现20次
    re.match('[a-zA-Z]{,20}')


def test03():
    # 匹配以数字开头字符串,后面任意
    re.match('^\d.*', '2eadsad')

    # 匹配以小写字母结尾
    re.match('.*[a-z]&', '1232ASDz')

    # 开头和结尾只能是一个数字
    re.match('^\d$', '8')  # 钉死开头和结尾

    # 匹配asd以外的任意一个字符
    re.match('[^asd]', 'g')

    # 匹配139邮箱地址
    re.match('[a-zA-Z0-9_]{4,20}@139\.com', '1234@139.com')  # 表达式中有点.可以用转义 \

    # 11位手机号码,1开头，第二位3-9
    re.match('1[3-9]\d{9}$', '17674797554')  # match函数自动添加^

    # 匹配微博话题   #幸福#是奋斗出来的#
    re.match('#.*#', '#幸福#是奋斗出来的#')  # 当出现多种可能的匹配时，match函数贪婪匹配，越多越好
    # 非贪婪匹配
    re.match('#.*?#', '#幸福#是奋斗出来的#')  # 只匹配出幸福


def test04():
    # 分组匹配|符号的使用
    # 匹配11位手机号码或者做座机号 3-4位区号加-8位电话
    re.match('1[3-9]\d{9}$|0\d{2,3}-\d{8}$', '')

    # 匹配出163，qq，139邮箱
    re.match('[a-zA-Z0-9_]{4,20}@(163|qq|139)\.com', '1741959256@qq.com')

    # 提取 qq:1741859256 这样的数据，分别提取出qq和账号
    res = re.match('(qq|QQ):(1\d{4,14})$', 'QQ:1741959256')
    if res:
        print(res.group(0))
        print(res.group(1))
        print(res.group(2))

    # 验证IPv4地址是否有效
    re.match('((\d\d?|1\d\d|2[0-4]\d|25[0-5])\.){3}(1\d\d|2[0-4]\d|25[0-5]|\d\d?)$', '')

    # 需求: 匹配出 <html><h1>www.itcast.com</h1></html>
    res = re.match('<([a-zA-z1-6]+)><([a-zA-z1-6]+)>.*</\\2></\\1>', '<html><h1>www.itcast.com</h1></html>')
    print(res.group())
    # 给分组起别名并引用别名实现
    res = re.match('<(?P<name1>[a-zA-z1-6]+)><(?P<name2>[a-zA-z1-6]+)>.*</(?P=name2)></(?P=name1)>',
                   '<html><h1>www.itcast.com</h1></html>')
    print(res.group())


def main():
    # test01()
    # test02()
    # test03()
    test04()


if __name__ == '__main__':
    main()
